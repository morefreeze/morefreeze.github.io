---
layout: post
title: "决战commafree code——Algorithm C"
description: "介绍如何通过巧妙回溯算法来构建 commafree code 集合"
category: algorithm
comments: true
tags: [algorithm, knuth, code]
---

{% include JB/setup %}

## 引言
在[上一篇文章](/2024/11/commafree-code-gen.html)中，我们介绍了如何通过递归算法来构建 commafree code 集合。这种方法的缺点是，当集合中的 code 数量增加时，递归的复杂度呈指数上升，导致算法的效率降低。但在最后我们有了一些优化的数据结构，帮助我们快速地添加和删除元素。本文将介绍如何通过巧妙的回溯算法来构建 commafree code 集合。
<!--more-->

## Algorithm C
### 框架
整体的算法框架很简单，分为5步：
1. 初始化需要的数组
2. 开始尝试选择主串
3. 更新选择带来的影响
4. 继续尝试（递归），当需要打印结果时，就打印
5. 回溯


### 初始化
这一步单独提出来是因为在上一篇介绍的数据结构，有不下10个数组要初始化，他们的作用主要是记录颜色和候选集，以及记录递归信息方便回溯。我尝试用伪代码来描述，但是发现伪代码太长了，而且x, c 这些字母看得头疼，这里我们只关注 MEM 数组，回到上篇最后的例子：![alt text](/images/commafree-ex.png)
这是当m=2时，我们需要初始化的 MEM 数组，而它恰好每行16个存下了所有4位二进制，第一行记录的是每个 code 的颜色，可以看到 #0000 #0100 #1000 #1010 #1111 已经是红色了，其他3个是红色好理解，因为他们属于abab的形式，本身就被排除在外，为什么#0100和#1000也被涂成红色呢？接着往下看，并且过程中自己尝试解释下，我在最后会揭晓答案。
剩下的辅助数组和变量我们就不展开初始化了，接着进入到下一步。

### 尝试主串
接下来我们大胆地从候选集中选一个颜色是蓝色的码，选中之后将它变成绿色，假如这次我们选择 #0010，同时记录下这一步的选择，进入下一步。

### 更新&标记
#### 更新稀疏集合
当我们选了 #0010 后，根据7个稀疏集合的定义，我们要可以快速地更新他们，从而继续更新状态数组的颜色。对于 P 集合，我们只要把 #0010 相应的前缀链表“关闭”即可，比如 P1 在 MEM[20-24] 之间记录的是 $0\star \star \star$ 开头的码，那么只要令 MEM[30] 是链表头-1就行了，也就是 `MEM[30]=1f`，然后对于 P2，也一样“关闭” $00\star \star$，依此类推 S 集合也是如此处理。

最后来处理 CL 集合，它是记录蓝色词的循环移位集合，这里选了 #0010，那么就要把它所在的位移集合都移除掉，也就是 MEM[140-141] 代表的集合，将 `MEM[150]=13f`，更新前如下图：
![before cl](/images/commafree-before_cl.png)
更新后如下图：
![after cl](/images/commafree-after_cl.png)
#### 状态标记
你也许注意到在更新后的 CL 集合中，还少了 #1001，这又是为什么呢？
这里要引出又一个数组 poison，当我们选择了 #0010 后，我们将

$$(\star001, 0\star \star \star), (\star \star00,10\star \star), (\star \star \star 0,010\star)$$

放入 poison 数组，对于第一组，因为 $0\star \star \star$包含了绿色的 #0010，那么 $\star001$ 必然为红，也就可以把 #1001 变成红，也就解释了为什么上面 CL 也删掉 #1001（另外6个集合也要对应删掉 #1001）。换句话说，每一对前缀和后缀必须至少包含一绿一红，同理，第三组因为 $\star \star \star0$ 已经包含绿了，那$010\star$都必须是红。对于第二组因为包含全为蓝，无法删除，就先保留。


### 回溯
当我们走到了尽头发现没有蓝色状态的码时，我们就要开始回溯了，鉴于精妙的数据结构，我们只要完成 更新&标记 的逆操作就好，对于poison 数组的记录，我们只要把上面单独删除的码加回到各个集合就好，这里特别提一下，因为稀疏集合在删除时只是把待删元素交换到末位没有物理删除，所以添加回来只要简单改一下 TAIL 指针就好。然后对于这次选中的候选码，简单地“打开”集合就好，也是修改 TAIL 指针。


## 小结
本文详细介绍了可以看到虽然搜索算法不可避免的是指数级的复杂度，但还是能通过巧妙的数据结构和搜索策略来提高效率。

最后回答下初始化那节遗留的问题，为什么 #0001 和 #0010 在初始化时就是红色了，
因为题目定义解法必须包括#0001或者#0010其中一个，不管选哪个，#0100和#1000都和#0001或者#0010属于同一个主码，所以被排除。
## 课后题
最复杂的莫过于书中列出的表格，如果你恰好有书，可以看到关于算法C的表格1和表格2，它们分别展示了算法C的第1步和第2步，但实际操作起来我发现了一些有趣的地方，留下几道问题帮助读者更好理解MEM的奥妙所在。
1. 在表格1中，可以看到20这行分成了两部分，每部分5个数，为什么前半部分记录了#0001 #0010 #0011是递增的，后半部分第一个却是#1100而不是#1001呢？
2. 接上题，你的答案能解释MEM[5d]和MEM[5e]吗？MEM[bc]和MEM[bd]呢？
3. 在表格1中，最后3行cl数组的赋值顺序是什么？为什么MEM[146]是#1100而MEM[147]是#1001排在后面呢？
4. 为什么初始化首先排除了#0100和#1000？（有没有好好听讲）

## 后记
其实这3篇文章只是对 Knuth 的TAOCP 4B 中 algorithm C粗浅解读，虽然书里列出了算法的12345步，但我并不认为用序号的形式展示一段带分支的代码是个好主意，而直接用伪码反而更加清晰，所以我在叙述时完全抛开了书中繁琐的步骤，而是从更符合代码直觉的角度上介绍了算法的实现。

PS：发现一些书中的错误，在Ex41和算法C的实现中，Knuth偶尔会把MEM的地址写成40d，而应该是4d，不幸的是这中错误已经被人指出来了，如果想拿到Knuth签名的San Serriffe银行支票还是要趁早。
