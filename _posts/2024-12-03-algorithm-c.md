---
layout: post
title: "决战commafree code——Algorithm C"
description: "介绍如何通过巧妙回溯算法来构建 commafree code 集合"
category: algorithm
comments: true
tags: [algorithm, knuth, code]
---

{% include JB/setup %}

## 引言
在[上一篇文章](/2024/11/commafree-code-gen.html)中，我们介绍了如何通过递归算法来构建 commafree code 集合。这种方法的缺点是，当集合中的 code 数量增加时，递归的复杂度呈指数上升，导致算法的效率降低。但在最后我们有了一些优化的数据结构，帮助我们快速地添加和删除元素。本文将介绍如何通过巧妙的回溯算法来构建 commafree code 集合。
<!--more-->

## Algorithm C
### 框架
整体的算法框架很简单，分为5步：
1. 初始化需要的数组
2. 开始尝试选择主串
3. 更新选择带来的影响
4. 继续尝试（递归），当需要打印结果时，就打印
5. 回溯


### 初始化
这一步单独提出来是因为加上上一篇介绍的数据结构，有不下10个数组要初始化，他们的作用主要是记录颜色和候选集，以及记录递归信息方便回溯。我尝试用伪代码来描述，但是发现伪代码太长了，而且x, c 这些字母看得头疼，这里我们只专注 MEM 数组，回到上篇最后的例子：![alt text](/images/commafree-ex.png)
这是当m=2时，我们需要初始化的MEM数组，而它恰好每行16个存下了所有4位二进制，第一行记录的是每个 code 的颜色，可以看到 #0000 #0100 #1000 #1010 #1111 已经是红色了，其他3个是红色好理解，因为他们属于abab的形式，本身就被排除在外，为什么#0100和#1000也被涂成红色呢？因为题目定义解法必须包括#0001或者#0010其中一个，不管选哪个，#0100和#1000都和#0001或者#0010属于同一个主码，所以被排除。
以此类推初始化好MEM剩下的部分。

### 尝试主串

### 更新&标记

### 回溯


## 小结
本文详细介绍了可以看到虽然搜索算法不可避免的是指数级的复杂度，但还是能通过巧妙的数据结构和搜索策略来提高效率。
## 课后题
最复杂的莫过于书中列出的表格，如果你恰好有书，可以看到关于算法C的表格1和表格2，它们分别展示了算法C的第1步和第2步，但实际操作起来我发现了一些有趣的地方，留下几道问题帮助读者更好理解MEM的奥妙所在。
1. 在表格1中，可以看到20这行分成了两部分，每部分5个数，为什么前半部分记录了#0001 #0010 #0011是递增的，后半部分第一个却是#1100而不是#1001呢？
2. 接上题，你的答案能解释MEM[5d]和MEM[5e]吗？MEM[bc]和MEM[bd]呢？
3. 在表格1中，最后3行cl数组的赋值顺序是什么？为什么MEM[146]是#1100而MEM[147]是#1001排在后面呢？
4. 为什么初始化首先排除了#0100和#1000？（有没有好好听讲）

## 后记
其实这3篇文章只是对 Knuth 的TAOCP 4B 中 algorithm C粗浅解读，虽然书里列出了算法的12345步，但我并不认为用序号的形式展示一段带分支的代码是个好主意，而直接用伪码反而更加清晰，所以我在叙述时完全抛开了书中繁琐的步骤，而是从更符合代码直觉的角度上介绍了算法的实现。

PS：发现一些书中的错误，在Ex41和算法C的实现中，Knuth偶尔会把MEM的地址写成40d，而应该是4d，不幸的是这中错误已经被人指出来了，如果想拿到Knuth签名的San Serriffe银行支票还是要趁早。
