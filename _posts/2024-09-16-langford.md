---
layout: post
title: "利用链表回溯生成 Langford 对"
description: ""
category: note
comments: true
tags: [algorithm, knuth]
---

{% include JB/setup %}

## 引言

我发现在以前的回溯算法中，很少提到链表的使用，虽然 Dancing link 算法已经用的炉火纯青了，但介绍它属于是“跳级”了，咱们既然从零单排回溯算法，那还要从链表在回溯中的简单用法讲起，这就要提 langford 对的生成了。

Langford 对是一个组合数学中的概念。给定一个正整数 ，Langford 对是将数字 1 到 n 的每个数字重复两次，并以一种特定的方式排列，使得两个相同的数字之间恰好间隔等于该数字的位置数。
例如，对于 n=4，一种可能的 Langford 对排列是 23421314。在这里，每个数字重复两次，且两个 1 之间间隔 1 个位置；两个 2 之间间隔 2 个位置；以此类推。

<!--more-->

## 青铜回溯

废话不多说，直接手撕代码。

{% highlight python linenos %}
sorted_num = sorted(remaining)
for num in sorted_num:
if pos + num + 1 < 2 \* n and sequence[pos + num + 1] == 0:
sequence[pos] = sequence[pos + num + 1] = num
remaining.remove(num)
results.extend(backtrack(sequence, remaining))
remaining.add(num)
sequence[pos] = sequence[pos + num + 1] = 0

{% endhighlight %}

`remaining` 保留了剩余的数字，每次取出一个填入数组 `sequence` 第一个为 0 的位置，填入时要做 2 件事：

1. 更新 `sequence` 的 2 个位置
2. 把 `num` 从 `remaining` 删除

## 白银优化

说实话，如果不是为了展示链表的快速修改和回复，我觉得上面的代码已经够用了。
这里我们引入一个循环链表 `p`，它本身是一个长度为 n+1 的数组，还有一个数组 `y[l]` 记录链表的位置，整个算法 L 的步骤如下：

1. 初始化，p 的每个元素依次指向后一个元素，并且最后的 $p_n\leftarrow0$
1. 进入第$l$层，令 $k\leftarrow p_0$，如果 $k=0$ 那么找到一组解，跳到第 5 步，否则令 $j\leftarrow0$，当$x_l<0$令$l\leftarrow l+1$
1. 尝试$x_l$，这时 $k=p_j$ 并且 l 位是空位，如果 $l+k+1>2n$，跳到第 5 步，否则如果$x_{l+k+1}=0$，令$x_l\leftarrow k, x_{l+k+1}\leftarrow-k,y_l\leftarrow j,p_j\leftarrow p_k$
1. 接着尝试，令$j\leftarrow k, k\leftarrow p_j$，如果$k\neq0$回到第 3 步继续尝试
1. 回溯，令$l\leftarrow l-1$。当$l>0 \And x_l<0$则$l\leftarrow l-1$，然后令$k\leftarrow x_l, x_l\leftarrow0, x_{l+k+1}\leftarrow0, j\leftarrow k, p_j\leftarrow k$，回到第 4 步。否则算法结束

